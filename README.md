**요약**
- MySQL 배치 삭제는 jdbc url 설정 필요
  - `jdbc:mysql://localhost:3306/bookstoredb?cachePreStmts=true&useServerPrepStmts=true&rewriteBatchedStatements=true`
- 다른 RDBMS의 경우
  - MySQL 관련 설정 제거하고
  - `spring.jpa.properties.hibernates.jdbc.batch_size` 값 설정
- 버전이 지정된 엔터티
  - `spring.jpa.properties.hibernate.jdbc.batch_versioned_data=true`
  - 하이버네이트 5부터는 기본적으로 활성화 됨
- `orphanRemoval=true` 사용
  - `CascadeType.REMOVE`와 혼동하지 말 것(연관관계를 해제해도 삭제되지 않음)
  - `deleteAllInBatch()` 메서드를 통한 삭제
    - orphanRemoval 또는 전이를 사용하지 않기 때문에 연관관계 레코드는 삭제되지 않음
  - `deleteInBatch(entities: Iterable<T>)` 메서드를 통한 삭제
    - orphanRemoval 또는 전이를 사용하지 않기 때문에 연관관계 레코드는 삭제되지 않음
  - `deleteAll(entities: Iterable<T>)`와 `delete(entity: T)` 메서드를 통한 삭제
    - 배치 처리가 사용됨
    - orphanRemoval을 사용하면 도서 레코드를 모두 삭제하고 이후 저자 삭제
- SQL의 `ON DELETE CASCATE` 사용
  - DB 자동 처리에 의존하므로 영속성 콘텍스트가 그에 따라 동기화되지 않음
  - `deleteAllInBatch()` 메서드를 통한 삭제
    - DB 전이 삭제를 트리거
    - 따라서 저자를 삭제하면 도서도 모두 삭제됨
  - `deleteInBatch(entities: Iterable<T>)` 메서드를 통한 삭제
    - DB 전이 삭제를 트리거
  - `deleteAll(entities: Iterable<T>)`와 `delete(entity: T)` 메서드를 통한 삭제
    - 배치 처리가 사용됨
    - DB 전이 삭제를 트리거
    - 엔터티 상태 전이와 DB 자동 처리가 함께 동작해서 영속성 콘텍스트가 부분적으로나마 동기화 됨(매우 효율적)
