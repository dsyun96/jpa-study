# 1주차
- [항목 14 - 하이버네이트 프록시를 통한 자식 측에서 부모 연관관계 채우기](https://github.com/dsyun96/jpa-study/tree/item-14)
- [항목 61 - @Transactional(readOnly = true)의 실제 작동 방식](https://github.com/dsyun96/jpa-study/tree/item-61)
- [항목 62 - 스프링이 @Transactional을 무시하는 이유](https://github.com/dsyun96/jpa-study/tree/item-62)
- [항목 63 - 트랜잭션 타임아웃 설정 및 롤백이 예상대로 작동하는지 확인하는 방법](https://github.com/dsyun96/jpa-study/tree/item-63)
- [항목 64 - 리포지터리 인터페이스에서 @Transactional을 사용하는 이유와 방법](https://github.com/dsyun96/jpa-study/tree/item-64)
- 항목 94 - 오프셋 페이지네이션 성능 저하 발생 시기와 이유
- 항목 95 - COUNT(*) OVER 및 Page<entity/dto>를 사용한 오프셋 페이지네이션 최적화 방법
- 항목 131 - 버전 기반(@Version) OptimisticLockException 발생 후 트랜잭션 재시도 방법
- 항목 132 - 버전 없는 OptimisticLockException의 트랜잭션 재시도 방법
- 부록 B - 연관관계 효율성

# 2주차
- [항목 1 - @OneToMany 연관관계를 효과적으로 구성하는 방법](https://github.com/dsyun96/jpa-study/tree/item-1)
- [항목 2 - 단방향 @OneToMany 연관관계를 피해야 하는 이유](https://github.com/dsyun96/jpa-study/tree/item-2)
- [항목 22 - 미래 영속성 콘텍스트에서 데이터베이스 변경 사항 전파를 위한 읽기 전용 엔터티의 사용 이유](https://github.com/dsyun96/jpa-study/tree/item-22)
- [항목 23 - 하이버네이트 Bytecode Enhancement를 통한 엔터티 속성 지연 로딩 방법](https://github.com/dsyun96/jpa-study/tree/item-23)
- [항목 86 - HikariCP 설정 커스터마이징 방법](https://github.com/dsyun96/jpa-study/tree/item-86)
- [항목 87 - 2개의 커넥션 풀을 갖는 2개의 데이터 소스 구성 방법](https://github.com/dsyun96/jpa-study/tree/item-87)
- [항목 96 - SELECT COUNT 서브쿼리 및 Page<entity/dto>를 사용한 오프셋 페이지네이션 최적화 방법](https://github.com/dsyun96/jpa-study/tree/item-96)
- [항목 97 - JOIN FETCH 및 Pageable 사용 방법](https://github.com/dsyun96/jpa-study/tree/item-97)
- [항목 100 - 키세트 페이지네이션 구현 방법](https://github.com/dsyun96/jpa-study/tree/item-100)
- [항목 101 - 키세트 페이지네이션에 다음 페이지 버튼 추가 방법](https://github.com/dsyun96/jpa-study/tree/item-101)

# 3주차
- [항목 3 - 단방향 @ManyToOne의 효율성](https://github.com/dsyun96/jpa-study/tree/item-3)
- [항목 4 - @ManyToMany 연관관계를 효과적으로 구성하는 방법](https://github.com/dsyun96/jpa-study/tree/item-4)
- [항목 5 - @ManyToMany 에서 Set이 List보다 나은 이유](https://github.com/dsyun96/jpa-study/tree/item-5)
- [항목 6 - CascadeType.REMOVE 및 orphanRemoval=true를 사용해 하위 엔터티 제거를 피해야 하는 이유와 시기](https://github.com/dsyun96/jpa-study/tree/item-6)
- [항목 24 - 서브엔터티를 통한 엔터티 속성 지연 로딩 방법](https://github.com/dsyun96/jpa-study/tree/item-24)
- [항목 98 - HHH000104 조치 방법](https://github.com/dsyun96/jpa-study/tree/item-98)
- [항목 99 - Slice<T> findAll() 구현 방법](https://github.com/dsyun96/jpa-study/tree/item-99)
- [항목 115 - 프록시를 언프록시하는 방법](https://github.com/dsyun96/jpa-study/tree/item-115)
- [항목 127 - 스프링에서 네임드(네이티브) 쿼리를 사용하는 방법](https://github.com/dsyun96/jpa-study/tree/item-127)
- [항목 134 - 장기 HTTP 통신에서의 낙관적 잠금 메커니즘 및 분리된 엔터티 사용 방법](https://github.com/dsyun96/jpa-study/tree/item-134)

# 4주차
- [항목 7 - JPA 엔터티 그래프를 통해 연관관계를 가져오는 방법](https://github.com/dsyun96/jpa-study/tree/item-7)
- [항목 8 - JPA 엔터티 서브그래프를 통해 연관관계를 가져오는 방법](https://github.com/dsyun96/jpa-study/tree/item-8)
- [항목 9 - 엔터티 그래프 및 기본 속성 처리 방법](https://github.com/dsyun96/jpa-study/tree/item-9)
- [항목 10 - 하이버네이트 @Where 어노테이션을 통한 연관관계 필터링 처리](https://github.com/dsyun96/jpa-study/tree/item-10)
- [항목 16 - 불변 엔터티 작성 방법](https://github.com/dsyun96/jpa-study/tree/item-16)
- [항목 17 - 엔터티 복제 방법](https://github.com/dsyun96/jpa-study/tree/item-17)
- [항목 25 - 스프링 프로젝션을 통한 DTO 가져오기](https://github.com/dsyun96/jpa-study/tree/item-25)
