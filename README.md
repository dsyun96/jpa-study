# 1주차
- [항목 14 - 하이버네이트 프록시를 통한 자식 측에서 부모 연관관계 채우기](https://github.com/dsyun96/jpa-study/tree/item-14)
- [항목 61 - @Transactional(readOnly = true)의 실제 작동 방식](https://github.com/dsyun96/jpa-study/tree/item-61)
- [항목 62 - 스프링이 @Transactional을 무시하는 이유](https://github.com/dsyun96/jpa-study/tree/item-62)
- [항목 63 - 트랜잭션 타임아웃 설정 및 롤백이 예상대로 작동하는지 확인하는 방법](https://github.com/dsyun96/jpa-study/tree/item-63)
- [항목 64 - 리포지터리 인터페이스에서 @Transactional을 사용하는 이유와 방법](https://github.com/dsyun96/jpa-study/tree/item-64)
- 항목 94 - 오프셋 페이지네이션 성능 저하 발생 시기와 이유
- 항목 95 - COUNT(*) OVER 및 Page<entity/dto>를 사용한 오프셋 페이지네이션 최적화 방법
- 항목 131 - 버전 기반(@Version) OptimisticLockException 발생 후 트랜잭션 재시도 방법
- 항목 132 - 버전 없는 OptimisticLockException의 트랜잭션 재시도 방법
- 부록 B - 연관관계 효율성

# 2주차
- [항목 1 - @OneToMany 연관관계를 효과적으로 구성하는 방법](https://github.com/dsyun96/jpa-study/tree/item-1)
- [항목 2 - 단방향 @OneToMany 연관관계를 피해야 하는 이유](https://github.com/dsyun96/jpa-study/tree/item-2)
- [항목 22 - 미래 영속성 콘텍스트에서 데이터베이스 변경 사항 전파를 위한 읽기 전용 엔터티의 사용 이유](https://github.com/dsyun96/jpa-study/tree/item-22)
- [항목 23 - 하이버네이트 Bytecode Enhancement를 통한 엔터티 속성 지연 로딩 방법](https://github.com/dsyun96/jpa-study/tree/item-23)
- [항목 86 - HikariCP 설정 커스터마이징 방법](https://github.com/dsyun96/jpa-study/tree/item-86)
- [항목 87 - 2개의 커넥션 풀을 갖는 2개의 데이터 소스 구성 방법](https://github.com/dsyun96/jpa-study/tree/item-87)
- [항목 96 - SELECT COUNT 서브쿼리 및 Page<entity/dto>를 사용한 오프셋 페이지네이션 최적화 방법](https://github.com/dsyun96/jpa-study/tree/item-96)
- [항목 97 - JOIN FETCH 및 Pageable 사용 방법](https://github.com/dsyun96/jpa-study/tree/item-97)
- [항목 100 - 키세트 페이지네이션 구현 방법](https://github.com/dsyun96/jpa-study/tree/item-100)
- [항목 101 - 키세트 페이지네이션에 다음 페이지 버튼 추가 방법](https://github.com/dsyun96/jpa-study/tree/item-101)

# 3주차
- [항목 3 - 단방향 @ManyToOne의 효율성](https://github.com/dsyun96/jpa-study/tree/item-3)
- [항목 4 - @ManyToMany 연관관계를 효과적으로 구성하는 방법](https://github.com/dsyun96/jpa-study/tree/item-4)
- [항목 5 - @ManyToMany 에서 Set이 List보다 나은 이유](https://github.com/dsyun96/jpa-study/tree/item-5)
- [항목 6 - CascadeType.REMOVE 및 orphanRemoval=true를 사용해 하위 엔터티 제거를 피해야 하는 이유와 시기](https://github.com/dsyun96/jpa-study/tree/item-6)
- [항목 24 - 서브엔터티를 통한 엔터티 속성 지연 로딩 방법](https://github.com/dsyun96/jpa-study/tree/item-24)
- [항목 98 - HHH000104 조치 방법](https://github.com/dsyun96/jpa-study/tree/item-98)
- [항목 99 - Slice<T> findAll() 구현 방법](https://github.com/dsyun96/jpa-study/tree/item-99)
- [항목 115 - 프록시를 언프록시하는 방법](https://github.com/dsyun96/jpa-study/tree/item-115)
- [항목 127 - 스프링에서 네임드(네이티브) 쿼리를 사용하는 방법](https://github.com/dsyun96/jpa-study/tree/item-127)
- [항목 134 - 장기 HTTP 통신에서의 낙관적 잠금 메커니즘 및 분리된 엔터티 사용 방법](https://github.com/dsyun96/jpa-study/tree/item-134)

# 4주차
- [항목 7 - JPA 엔터티 그래프를 통해 연관관계를 가져오는 방법](https://github.com/dsyun96/jpa-study/tree/item-7)
- [항목 8 - JPA 엔터티 서브그래프를 통해 연관관계를 가져오는 방법](https://github.com/dsyun96/jpa-study/tree/item-8)
- [항목 9 - 엔터티 그래프 및 기본 속성 처리 방법](https://github.com/dsyun96/jpa-study/tree/item-9)
- [항목 10 - 하이버네이트 @Where 어노테이션을 통한 연관관계 필터링 처리](https://github.com/dsyun96/jpa-study/tree/item-10)
- [항목 16 - 불변 엔터티 작성 방법](https://github.com/dsyun96/jpa-study/tree/item-16)
- [항목 17 - 엔터티 복제 방법](https://github.com/dsyun96/jpa-study/tree/item-17)
- [항목 25 - 스프링 프로젝션을 통한 DTO 가져오기](https://github.com/dsyun96/jpa-study/tree/item-25)
- [항목 26 - 스프링 프로젝션에서 엔터티를 추가하는 방법](https://github.com/dsyun96/jpa-study/tree/item-26)
- [항목 46 - 스프링 부트 스타일 배치 등록 방법](https://github.com/dsyun96/jpa-study/tree/item-46)
- [항목 47 - 부모-자식 관계 배치 등록 최적화 방법](https://github.com/dsyun96/jpa-study/tree/item-47)

# 5주차
- [항목 11 - @MapsId를 통한 단방향/양방향 @OneToOne 최적화 방법](https://github.com/dsyun96/jpa-study/tree/item-11)
- [항목 20 - 애그리거트 루트로부터 최적의 도메인 이벤트 발행](https://github.com/dsyun96/jpa-study/tree/item-20)
- [항목 48 - 세션 수준에서 배치 크기 제어 방법](https://github.com/dsyun96/jpa-study/tree/item-48)
- [항목 49 - 포크/조인 JDBC 배치 처리 방법](https://github.com/dsyun96/jpa-study/tree/item-49)
- [항목 50 - CompletableFuture를 통한 엔터티 배치 처리](https://github.com/dsyun96/jpa-study/tree/item-50)
- [항목 51 - 배치 업데이트에 대한 효율적인 처리 방법](https://github.com/dsyun96/jpa-study/tree/item-51)
- [항목 52 - 효율적으로 배치 삭제하는 방법(연관관계 없이)](https://github.com/dsyun96/jpa-study/tree/item-52)
- [항목 53 - 효율적으로 배치 삭제하는 방법(연관관계와 함께)](https://github.com/dsyun96/jpa-study/tree/item-53)
- [항목 54 - 배치로 연관관계 가져오는 방법](https://github.com/dsyun96/jpa-study/tree/item-54)
- [항목 84 - 임계치를 사용한 느린 쿼리 로그 방법](https://github.com/dsyun96/jpa-study/tree/item-84)
- [항목 85 - 트랜잭션 및 쿼리 메서드 상세 로깅](https://github.com/dsyun96/jpa-study/tree/item-85)

# 6주차
- [항목 18: 더티 트래킹을 활성화하는 이유와 방법](https://github.com/dsyun96/jpa-study/tree/item-18)
- [항목 19: 불리언을 Yes/No로 매핑하는 방법](https://github.com/dsyun96/jpa-study/tree/item-19)
- [항목 68: equals() 및 hashCode()를 올바로 오버라이드하는 방법](https://github.com/dsyun96/jpa-study/tree/item-68)
- [항목 81: SQL문 카운트 및 어설션 사용 이유와 방법](https://github.com/dsyun96/jpa-study/tree/item-81)
- [항목 82: 프리페어드 스테이트먼트 바인딩 및 추출 파라미터 로깅 방법](https://github.com/dsyun96/jpa-study/tree/item-82)
- [항목 83: 쿼리 상세 정보 로깅 방법](https://github.com/dsyun96/jpa-study/tree/item-83)
- [항목 110: OSIV 안티패턴 회피 이유와 방법](https://github.com/dsyun96/jpa-study/tree/item-110)
- [항목 126: 하이버네이트 @DynamicUpdate를 통해 수정된 칼럼만 UPDATE문에 포함하는 방법](https://github.com/dsyun96/jpa-study/tree/item-126)
- [항목 145: 자바 열거형을 데이터베이스에 효율적으로 매핑하는 방법](https://github.com/dsyun96/jpa-study/tree/item-145)
- [항목 146: JSON 자바 객체를 MySQL JSON 칼럼에 효율적으로 매핑하는 방법](https://github.com/dsyun96/jpa-study/tree/item-146)

# 7주차
- [항목 39: 단일 SELECT로 부모와 연관관계를 효율적으로 가져오는 방법](https://github.com/dsyun96/jpa-study/tree/item-39)
- [항목 40: JOIN과 JOIN FETCH 결정 방법](https://github.com/dsyun96/jpa-study/tree/item-40)
- [항목 69: 스프링 스타일로 하이버네이트 @NaturalId를 사용하는 방법](https://github.com/dsyun96/jpa-study/tree/item-69)
- [항목 70: 하이버네이트 @NaturalId 사용 및 엔터티 식별자 조회 생략 방법](https://github.com/dsyun96/jpa-study/tree/item-70)
- [항목 71: @NaturalId 칼럼 참조 연관관계 정의 방법](https://github.com/dsyun96/jpa-study/tree/item-71)
- [항목 72: 자동 생성 키를 얻는 방법](https://github.com/dsyun96/jpa-study/tree/item-72)
- [항목 73: 커스텀 시퀀스 ID를 생성하는 방법](https://github.com/dsyun96/jpa-study/tree/item-73)
- [항목 92: 스프링 부트에서 Flyway 설정 방법](https://github.com/dsyun96/jpa-study/tree/item-92)
- [항목 93: schema-*.sql을 통한 두 데이터베이스 생성과 엔터티 매칭 방법](https://github.com/dsyun96/jpa-study/tree/item-93)
- [항목 104: JPA 콜백 설정 방법](https://github.com/dsyun96/jpa-study/tree/item-104)

# 8주차
- [항목 12: 단 하나의 연관관계만 Null이 아닌지 확인하는 방법](https://github.com/dsyun96/jpa-study/tree/item-12)
- [항목 13: 엔터티의 플루언트 API 스타일 적용 방법](https://github.com/dsyun96/jpa-study/tree/item-13)
- [항목 74: 복합 기본키를 효율적으로 구현하는 방법](https://github.com/dsyun96/jpa-study/tree/item-74)
- [항목 75: 복합키에서 관계를 정의하는 방법](https://github.com/dsyun96/jpa-study/tree/item-75)
- [항목 77: 산출된 비영속 속성 매핑 방법](https://github.com/dsyun96/jpa-study/tree/item-77)
- [항목 78: @Generated를 통한 산출된 영속 속성 매핑 방법](https://github.com/dsyun96/jpa-study/tree/item-78)
- [항목 79: JPQL 쿼리에서 여러 파라미터와 함께 SQL 함수 사용 방법](https://github.com/dsyun96/jpa-study/tree/item-79)
- [항목 80: @JoinFormula를 통해 @ManyToOne 관계를 SQL 쿼리에 매핑하는 방법](https://github.com/dsyun96/jpa-study/tree/item-80)
- [항목 90: 영속성 콘텍스트를 확인하는 방법](https://github.com/dsyun96/jpa-study/tree/item-90)
- [항목 91: 테이블 메타데이터 추출 방법](https://github.com/dsyun96/jpa-study/tree/item-91)

# 9주차
- [항목 21: 다이렉트 페치 사용 방법](https://github.com/dsyun96/jpa-study/tree/item-21)
- [항목 44: JOIN 페이지네이션 방법](https://github.com/dsyun96/jpa-study/tree/item-44)
- [항목 45: 결과 세트를 스트림하는 방법(MySQL) 및 Streamable 유틸리티의 사용 방법](https://github.com/dsyun96/jpa-study/tree/item-45)
- [항목 56: @ElementCollection 컬렉션 JOIN FETCH 방법](https://github.com/dsyun96/jpa-study/tree/item-56)
- [항목 57: @ElementCollection에 대한 DTO 방법](https://github.com/dsyun96/jpa-study/tree/item-57)
- [항목 116: 데이터베이스 뷰 매핑 방법](https://github.com/dsyun96/jpa-study/tree/item-116)
- [항목 117: 데이터베이스 뷰 수정 방법](https://github.com/dsyun96/jpa-study/tree/item-117)
- [항목 120: 모든 그룹의 상위 N개 행을 효율적으로 찾는 방법](https://github.com/dsyun96/jpa-study/tree/item-120)
- [항목 122: IN 절 파라미터 패딩을 통한 SQL 캐싱 향상 방법](https://github.com/dsyun96/jpa-study/tree/item-122)
- [항목 135: 엔터티가 수정되지 않은 경우에도 잠긴 엔터티 버전을 증가시키는 방법](https://github.com/dsyun96/jpa-study/tree/item-135)

# 10주차
- [항목 31: 생성자 표현식을 통해 DTO를 가져오는 방법](https://github.com/dsyun96/jpa-study/tree/item-31)
- [항목 32: 생성자 표현식을 통해 DTO에서 엔터티를 가져오지 말아야 하는 이유](https://github.com/dsyun96/jpa-study/tree/item-32)
- [항목 58: @ElementCollection과 @OrderColumn을 함께 사용해야 하는 이유와 시기](https://github.com/dsyun96/jpa-study/tree/item-58)
- [항목 59: 엔터티 컬렉션 병합 방법](https://github.com/dsyun96/jpa-study/tree/item-59)
- [항목 88: 생성 및 수정 시간과 엔터티 사용자 추적 방법](https://github.com/dsyun96/jpa-study/tree/item-88)
- [항목 107: 중복된 save() 호출을 피하는 방법](https://github.com/dsyun96/jpa-study/tree/item-107)
- [항목 138: 단일 테이블 상속을 효율적으로 사용하는 방법](https://github.com/dsyun96/jpa-study/tree/item-138)
- 항목 139: SINGLE_TABLE 상속 계층 구조에서 특정 하위 클래스 가져오기
- 항목 140: 조인 테이블 상속의 효율적 사용 방법
- 항목 142: @MappedSuperclass 효율적 사용 방법
