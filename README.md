# 요약
- 단방향으로 하면 별도 테이블을 생성하고, insert/delete 시 생성되는 쿼리가 상당히 많아진다
    - 새로운 도서를 추가할 때 하이버네이트는 연결 테이블에서 모든 연관 도서를 삭제한 후 메모리에 새 도서를 추가하고 결과를 다시 등록함
    - 도서를 삭제할 때도 하이버네이트는 연결 테이블에서 모든 연관 도서를 삭제한 후 메모리에서 도서를 제거하고 나머지 도서를 등록함
- @OrderColumn을 @OneToMany와 함께 사용하면 연결 테이블에는 새로운 칼럼이 생성된다
    - 연결 테이블의 별도 데이터베이스 칼럼으로 항목 인덱스를 구체화하도록 하이버네이트에게 지시함
    - 연관 도서를 메모리에 추가하기 위해 테이블에서 데이터를 삭제하지 않게 됨
    - 그러나 컬렉션의 끝에서 멀어질수록 얻게 되는 이점이 작아짐(그만큼 UPDATE문 발생)
- @JoinColumn을 @OneToMany와 함께 사용하면 연결 테이블이 사라지고 자식 측 테이블에 새로운 칼럼이 생성된다
    - 이번엔 컬렉션의 끝이든 처음이든 단 1번의 추가 UPDATE문이 발생
- 결론 : 양방향 @OneToMany를 쓰거나 단방향 @ManyToOne을 사용하라

# 추가 정보
- 50페이지에서 자식 측 엔터티에 @ManyToOne을 추가할 때 부모 측 엔터티의 @OneToMany에 mappedBy를 빠뜨리면 여전히 별도 연결 테이블(author_books)을 생성함.
