# 1주차
- [항목 14 - 하이버네이트 프록시를 통한 자식 측에서 부모 연관관계 채우기](https://github.com/dsyun96/jpa-study/tree/item-14)
- [항목 61 - @Transactional(readOnly = true)의 실제 작동 방식](https://github.com/dsyun96/jpa-study/tree/item-61)
- [항목 62 - 스프링이 @Transactional을 무시하는 이유](https://github.com/dsyun96/jpa-study/tree/item-62)
- [항목 63 - 트랜잭션 타임아웃 설정 및 롤백이 예상대로 작동하는지 확인하는 방법](https://github.com/dsyun96/jpa-study/tree/item-63)
- [항목 64 - 리포지터리 인터페이스에서 @Transactional을 사용하는 이유와 방법](https://github.com/dsyun96/jpa-study/tree/item-64)
- 항목 94 - 오프셋 페이지네이션 성능 저하 발생 시기와 이유
- 항목 95 - COUNT(*) OVER 및 Page<entity/dto>를 사용한 오프셋 페이지네이션 최적화 방법
- 항목 131 - 버전 기반(@Version) OptimisticLockException 발생 후 트랜잭션 재시도 방법
- 항목 132 - 버전 없는 OptimisticLockException의 트랜잭션 재시도 방법
- 부록 B - 연관관계 효율성

# 2주차
- [항목 1 - @OneToMany 연관관계를 효과적으로 구성하는 방법](https://github.com/dsyun96/jpa-study/tree/item-1)
- [항목 2 - 단방향 @OneToMany 연관관계를 피해야 하는 이유](https://github.com/dsyun96/jpa-study/tree/item-2)
- [항목 22 - 미래 영속성 콘텍스트에서 데이터베이스 변경 사항 전파를 위한 읽기 전용 엔터티의 사용 이유](https://github.com/dsyun96/jpa-study/tree/item-22)
- [항목 23 - 하이버네이트 Bytecode Enhancement를 통한 엔터티 속성 지연 로딩 방법](https://github.com/dsyun96/jpa-study/tree/item-23)
- [항목 86 - HikariCP 설정 커스터마이징 방법](https://github.com/dsyun96/jpa-study/tree/item-86)
- [항목 87 - 2개의 커넥션 풀을 갖는 2개의 데이터 소스 구성 방법](https://github.com/dsyun96/jpa-study/tree/item-87)
- [항목 96 - SELECT COUNT 서브쿼리 및 Page<entity/dto>를 사용한 오프셋 페이지네이션 최적화 방법](https://github.com/dsyun96/jpa-study/tree/item-96)
- [항목 97 - JOIN FETCH 및 Pageable 사용 방법](https://github.com/dsyun96/jpa-study/tree/item-97)
- [항목 100 - 키세트 페이지네이션 구현 방법](https://github.com/dsyun96/jpa-study/tree/item-100)
- [항목 101 - 키세트 페이지네이션에 다음 페이지 버튼 추가 방법](https://github.com/dsyun96/jpa-study/tree/item-101)

# 3주차
- [항목 3 - 단방향 @ManyToOne의 효율성](https://github.com/dsyun96/jpa-study/tree/item-3)
- [항목 4 - @ManyToMany 연관관계를 효과적으로 구성하는 방법](https://github.com/dsyun96/jpa-study/tree/item-4)
- [항목 5 - @ManyToMany 에서 Set이 List보다 나은 이유](https://github.com/dsyun96/jpa-study/tree/item-5)
- [항목 6 - CascadeType.REMOVE 및 orphanRemoval=true를 사용해 하위 엔터티 제거를 피해야 하는 이유와 시기](https://github.com/dsyun96/jpa-study/tree/item-6)
- [항목 24 - 서브엔터티를 통한 엔터티 속성 지연 로딩 방법](https://github.com/dsyun96/jpa-study/tree/item-24)
- [항목 98 - HHH000104 조치 방법](https://github.com/dsyun96/jpa-study/tree/item-98)
- [항목 99 - Slice<T> findAll() 구현 방법](https://github.com/dsyun96/jpa-study/tree/item-99)
- [항목 115 - 프록시를 언프록시하는 방법](https://github.com/dsyun96/jpa-study/tree/item-115)
- [항목 127 - 스프링에서 네임드(네이티브) 쿼리를 사용하는 방법](https://github.com/dsyun96/jpa-study/tree/item-127)
- [항목 134 - 장기 HTTP 통신에서의 낙관적 잠금 메커니즘 및 분리된 엔터티 사용 방법](https://github.com/dsyun96/jpa-study/tree/item-134)

# 4주차
- [항목 7 - JPA 엔터티 그래프를 통해 연관관계를 가져오는 방법](https://github.com/dsyun96/jpa-study/tree/item-7)
- [항목 8 - JPA 엔터티 서브그래프를 통해 연관관계를 가져오는 방법](https://github.com/dsyun96/jpa-study/tree/item-8)
- [항목 9 - 엔터티 그래프 및 기본 속성 처리 방법](https://github.com/dsyun96/jpa-study/tree/item-9)
- [항목 10 - 하이버네이트 @Where 어노테이션을 통한 연관관계 필터링 처리](https://github.com/dsyun96/jpa-study/tree/item-10)
- [항목 16 - 불변 엔터티 작성 방법](https://github.com/dsyun96/jpa-study/tree/item-16)
- [항목 17 - 엔터티 복제 방법](https://github.com/dsyun96/jpa-study/tree/item-17)
- [항목 25 - 스프링 프로젝션을 통한 DTO 가져오기](https://github.com/dsyun96/jpa-study/tree/item-25)
- [항목 26 - 스프링 프로젝션에서 엔터티를 추가하는 방법](https://github.com/dsyun96/jpa-study/tree/item-26)
- [항목 46 - 스프링 부트 스타일 배치 등록 방법](https://github.com/dsyun96/jpa-study/tree/item-46)
- [항목 47 - 부모-자식 관계 배치 등록 최적화 방법](https://github.com/dsyun96/jpa-study/tree/item-47)

# 5주차
- [항목 11 - @MapsId를 통한 단방향/양방향 @OneToOne 최적화 방법](https://github.com/dsyun96/jpa-study/tree/item-11)
- [항목 20 - 애그리거트 루트로부터 최적의 도메인 이벤트 발행](https://github.com/dsyun96/jpa-study/tree/item-20)
- [항목 48 - 세션 수준에서 배치 크기 제어 방법](https://github.com/dsyun96/jpa-study/tree/item-48)
- [항목 49 - 포크/조인 JDBC 배치 처리 방법](https://github.com/dsyun96/jpa-study/tree/item-49)
- [항목 50 - CompletableFuture를 통한 엔터티 배치 처리](https://github.com/dsyun96/jpa-study/tree/item-50)
- [항목 51 - 배치 업데이트에 대한 효율적인 처리 방법](https://github.com/dsyun96/jpa-study/tree/item-51)
- [항목 52 - 효율적으로 배치 삭제하는 방법(연관관계 없이)](https://github.com/dsyun96/jpa-study/tree/item-52)
- [항목 53 - 효율적으로 배치 삭제하는 방법(연관관계와 함께)](https://github.com/dsyun96/jpa-study/tree/item-53)
- [항목 54 - 배치로 연관관계 가져오는 방법](https://github.com/dsyun96/jpa-study/tree/item-54)
- [항목 84 - 임계치를 사용한 느린 쿼리 로그 방법](https://github.com/dsyun96/jpa-study/tree/item-84)
- [항목 85 - 트랜잭션 및 쿼리 메서드 상세 로깅](https://github.com/dsyun96/jpa-study/tree/item-85)

# 6주차
- [항목 18: 더티 트래킹을 활성화하는 이유와 방법](https://github.com/dsyun96/jpa-study/tree/item-18)
- [항목 19: 불리언을 Yes/No로 매핑하는 방법](https://github.com/dsyun96/jpa-study/tree/item-19)
- [항목 68: equals() 및 hashCode()를 올바로 오버라이드하는 방법](https://github.com/dsyun96/jpa-study/tree/item-68)
- [항목 81: SQL문 카운트 및 어설션 사용 이유와 방법](https://github.com/dsyun96/jpa-study/tree/item-81)
- 항목 82: 프리페어드 스테이트먼트 바인딩 및 추출 파라미터 로깅 방법
- 항목 83: 쿼리 상세 정보 로깅 방법
- 항목 110: OSIV 안티패턴 회피 이유와 방법
- 항목 126: 하이버네이트 @DynamicUpdate를 통해 수정된 칼럼만 UPDATE문에 포함하는 방법
- 항목 145: 자바 열거형을 데이터베이스에 효율적으로 매핑하는 방법
- 항목 146: JSON 자바 객체를 MySQL JSON 칼럼에 효율적으로 매핑하는 방법
