# 1주차
- [항목 14 - 하이버네이트 프록시를 통한 자식 측에서 부모 연관관계 채우기](https://github.com/dsyun96/jpa-study/tree/item-14)
- [항목 61 - @Transactional(readOnly = true)의 실제 작동 방식](https://github.com/dsyun96/jpa-study/tree/item-61)
- [항목 62 - 스프링이 @Transactional을 무시하는 이유](https://github.com/dsyun96/jpa-study/tree/item-62)
- [항목 63 - 트랜잭션 타임아웃 설정 및 롤백이 예상대로 작동하는지 확인하는 방법](https://github.com/dsyun96/jpa-study/tree/item-63)
- [항목 64 - 리포지터리 인터페이스에서 @Transactional을 사용하는 이유와 방법](https://github.com/dsyun96/jpa-study/tree/item-64)
- 항목 94 - 오프셋 페이지네이션 성능 저하 발생 시기와 이유
- 항목 95 - COUNT(*) OVER 및 Page<entity/dto>를 사용한 오프셋 페이지네이션 최적화 방법
- 항목 131 - 버전 기반(@Version) OptimisticLockException 발생 후 트랜잭션 재시도 방법
- 항목 132 - 버전 없는 OptimisticLockException의 트랜잭션 재시도 방법
- 부록 B - 연관관계 효율성

# 2주차
- [항목 1 - @OneToMany 연관관계를 효과적으로 구성하는 방법](https://github.com/dsyun96/jpa-study/tree/item-1)
- [항목 2 - 단방향 @OneToMany 연관관계를 피해야 하는 이유](https://github.com/dsyun96/jpa-study/tree/item-2)
- [항목 22 - 미래 영속성 콘텍스트에서 데이터베이스 변경 사항 전파를 위한 읽기 전용 엔터티의 사용 이유](https://github.com/dsyun96/jpa-study/tree/item-22)
- [항목 23 - 하이버네이트 Bytecode Enhancement를 통한 엔터티 속성 지연 로딩 방법](https://github.com/dsyun96/jpa-study/tree/item-23)
- [항목 86 - HikariCP 설정 커스터마이징 방법](https://github.com/dsyun96/jpa-study/tree/item-86)
- [항목 87 - 2개의 커넥션 풀을 갖는 2개의 데이터 소스 구성 방법](https://github.com/dsyun96/jpa-study/tree/item-87)
- [항목 96 - SELECT COUNT 서브쿼리 및 Page<entity/dto>를 사용한 오프셋 페이지네이션 최적화 방법](https://github.com/dsyun96/jpa-study/tree/item-96)
- [항목 97 - JOIN FETCH 및 Pageable 사용 방법](https://github.com/dsyun96/jpa-study/tree/item-97)
- 항목 100 - 키세트 페이지네이션 구현 방법
- 항목 101 - 키세트 페이지네이션에 다음 페이지 버튼 추가 방법
